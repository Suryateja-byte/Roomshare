generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
  binaryTargets   = ["native", "debian-openssl-3.0.x", "windows"]
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  extensions = [postgis]
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id                      String                @id @default(cuid())
  name                    String?
  email                   String?               @unique
  emailVerified           DateTime?
  image                   String?
  password                String?
  bio                     String?
  countryOfOrigin         String?
  languages               String[]
  isVerified              Boolean               @default(false)
  isAdmin                 Boolean               @default(false)
  isSuspended             Boolean               @default(false)
  notificationPreferences Json?
  createdAt               DateTime              @default(now())
  accounts                Account[]
  listings                Listing[]
  messages                Message[]
  sessions                Session[]
  conversations           Conversation[]        @relation("ConversationParticipants")
  savedListings           SavedListing[]
  reviewsWritten          Review[]              @relation("ReviewAuthor")
  reviewsReceived         Review[]              @relation("ReviewTarget")
  bookings                Booking[]
  reportsMade             Report[]              @relation("ReportsMade")
  reportsReviewed         Report[]              @relation("ReportsReviewed")
  recentlyViewed          RecentlyViewed[]
  notifications           Notification[]
  verificationRequests    VerificationRequest[]
  savedSearches           SavedSearch[]
  blockedUsers            BlockedUser[]         @relation("BlocksMade")
  blockedByUsers          BlockedUser[]         @relation("BlocksReceived")
  auditLogs               AuditLog[]            @relation("AuditLogs")
  typingStatuses          TypingStatus[]
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model PasswordResetToken {
  id        String   @id @default(cuid())
  email     String
  token     String   @unique
  expires   DateTime
  createdAt DateTime @default(now())

  @@unique([email, token])
}

model Listing {
  id             String           @id @default(cuid())
  ownerId        String
  title          String
  description    String
  price          Float
  images         String[]         @default([])
  amenities      String[]
  houseRules     String[]
  leaseDuration    String?
  roomType         String?
  languages        String[]  @default([])
  genderPreference String?
  householdGender  String?
  totalSlots       Int
  availableSlots Int
  moveInDate     DateTime?
  status         ListingStatus    @default(ACTIVE)
  viewCount      Int              @default(0)
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt
  owner          User             @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  location       Location?
  conversations  Conversation[]
  savedBy        SavedListing[]
  reviews        Review[]
  bookings       Booking[]
  reports        Report[]
  recentlyViewed RecentlyViewed[]
}

model SavedListing {
  id        String   @id @default(cuid())
  userId    String
  listingId String
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  listing   Listing  @relation(fields: [listingId], references: [id], onDelete: Cascade)

  @@unique([userId, listingId])
}

model Review {
  id            String   @id @default(cuid())
  authorId      String
  listingId     String?
  targetUserId  String?
  rating        Int
  comment       String
  createdAt     DateTime        @default(now())

  author        User            @relation("ReviewAuthor", fields: [authorId], references: [id], onDelete: Cascade)
  listing       Listing?        @relation(fields: [listingId], references: [id], onDelete: Cascade)
  targetUser    User?           @relation("ReviewTarget", fields: [targetUserId], references: [id], onDelete: Cascade)
  response      ReviewResponse?

  // One review per user per listing (duplicate prevention)
  @@unique([authorId, listingId])
}

enum BookingStatus {
  PENDING
  ACCEPTED
  REJECTED
  CANCELLED
}

enum ListingStatus {
  ACTIVE
  PAUSED
  RENTED
}

model Booking {
  id        String        @id @default(cuid())
  listingId String
  tenantId  String
  startDate DateTime
  endDate   DateTime
  status    BookingStatus @default(PENDING)
  totalPrice Float
  createdAt DateTime      @default(now())
  updatedAt DateTime      @updatedAt

  listing   Listing       @relation(fields: [listingId], references: [id], onDelete: Cascade)
  tenant    User          @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  // Prevent duplicate booking requests for same tenant/listing/dates
  @@unique([tenantId, listingId, startDate, endDate])
}

enum ReportStatus {
  OPEN
  RESOLVED
  DISMISSED
}

model Report {
  id         String       @id @default(cuid())
  listingId  String
  reporterId String
  reason     String
  details    String?
  status     ReportStatus @default(OPEN)
  adminNotes String?
  reviewedBy String?
  resolvedAt DateTime?
  createdAt  DateTime     @default(now())

  listing    Listing      @relation(fields: [listingId], references: [id], onDelete: Cascade)
  reporter   User         @relation("ReportsMade", fields: [reporterId], references: [id], onDelete: Cascade)
  reviewer   User?        @relation("ReportsReviewed", fields: [reviewedBy], references: [id])
}

model Location {
  id        String                   @id @default(cuid())
  listingId String                   @unique
  address   String
  city      String
  state     String
  zip       String
  coords    Unsupported("geometry")?
  listing   Listing                  @relation(fields: [listingId], references: [id], onDelete: Cascade)

  @@index([coords], map: "location_idx", type: Gist)
}

model Conversation {
  id             String         @id @default(cuid())
  listingId      String
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
  deletedAt      DateTime?      // Soft delete timestamp
  listing        Listing        @relation(fields: [listingId], references: [id], onDelete: Cascade)
  messages       Message[]
  participants   User[]         @relation("ConversationParticipants")
  typingStatuses TypingStatus[]
}

model Message {
  id             String       @id @default(cuid())
  senderId       String
  conversationId String
  content        String
  read           Boolean      @default(false)
  createdAt      DateTime     @default(now())
  deletedAt      DateTime?    // Soft delete timestamp
  deletedBy      String?      // User who deleted (for audit)
  sender         User         @relation(fields: [senderId], references: [id], onDelete: Cascade)
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
}

model RecentlyViewed {
  id        String   @id @default(cuid())
  userId    String
  listingId String
  viewedAt  DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  listing   Listing  @relation(fields: [listingId], references: [id], onDelete: Cascade)

  @@unique([userId, listingId])
  @@index([userId, viewedAt])
}

enum NotificationType {
  BOOKING_REQUEST
  BOOKING_ACCEPTED
  BOOKING_REJECTED
  BOOKING_CANCELLED
  NEW_MESSAGE
  NEW_REVIEW
  LISTING_SAVED
  SEARCH_ALERT
}

model Notification {
  id        String           @id @default(cuid())
  userId    String
  type      NotificationType
  title     String
  message   String
  link      String?
  read      Boolean          @default(false)
  createdAt DateTime         @default(now())
  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, read])
}

enum VerificationStatus {
  PENDING
  APPROVED
  REJECTED
}

model VerificationRequest {
  id            String             @id @default(cuid())
  userId        String
  documentType  String             // "passport", "driver_license", "national_id"
  documentUrl   String             // URL to uploaded document image
  selfieUrl     String?            // URL to selfie for matching
  status        VerificationStatus @default(PENDING)
  adminNotes    String?            // Notes from admin on rejection
  createdAt     DateTime           @default(now())
  updatedAt     DateTime           @updatedAt
  reviewedAt    DateTime?
  reviewedBy    String?            // Admin user ID who reviewed
  user          User               @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([status])
}

enum AlertFrequency {
  INSTANT
  DAILY
  WEEKLY
}

model SavedSearch {
  id             String         @id @default(cuid())
  userId         String
  name           String
  query          String?
  filters        Json           // Store all filter params as JSON
  alertEnabled   Boolean        @default(true)
  alertFrequency AlertFrequency @default(DAILY)
  lastAlertAt    DateTime?
  createdAt      DateTime       @default(now())
  user           User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([alertEnabled, lastAlertAt])
}

model ReviewResponse {
  id        String   @id @default(cuid())
  reviewId  String   @unique
  content   String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  review    Review   @relation(fields: [reviewId], references: [id], onDelete: Cascade)
}

/// This table contains check constraints and requires additional setup for migrations. Visit https://pris.ly/d/check-constraints for more info.
model spatial_ref_sys {
  srid      Int     @id
  auth_name String? @db.VarChar(256)
  auth_srid Int?
  srtext    String? @db.VarChar(2048)
  proj4text String? @db.VarChar(2048)
}

// Rate Limiting (Database-backed for Vercel serverless)
model RateLimitEntry {
  id          String   @id @default(cuid())
  identifier  String   // IP or userId:endpoint
  endpoint    String
  count       Int      @default(1)
  windowStart DateTime @default(now())
  expiresAt   DateTime

  @@unique([identifier, endpoint])
  @@index([expiresAt])
}


// User Blocking
model BlockedUser {
  id        String   @id @default(cuid())
  blockerId String
  blockedId String
  createdAt DateTime @default(now())

  blocker   User     @relation("BlocksMade", fields: [blockerId], references: [id], onDelete: Cascade)
  blocked   User     @relation("BlocksReceived", fields: [blockedId], references: [id], onDelete: Cascade)

  @@unique([blockerId, blockedId])
  @@index([blockerId])
  @@index([blockedId])
}

// Admin Audit Trail - Immutable log of all admin actions for security/compliance
model AuditLog {
  id          String   @id @default(cuid())
  adminId     String
  action      String   // e.g., "USER_SUSPENDED", "LISTING_DELETED", "REPORT_RESOLVED"
  targetType  String   // e.g., "User", "Listing", "Report"
  targetId    String
  details     Json?    // Additional context (old/new values, reason, etc.)
  ipAddress   String?  // For security tracking
  createdAt   DateTime @default(now())

  admin       User     @relation("AuditLogs", fields: [adminId], references: [id])

  @@index([adminId])
  @@index([targetType, targetId])
  @@index([createdAt])
  @@index([action])
}

model TypingStatus {
  id             String       @id @default(cuid())
  userId         String
  conversationId String
  isTyping       Boolean      @default(false)
  updatedAt      DateTime     @updatedAt

  user           User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  conversation   Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@unique([userId, conversationId])
  @@index([conversationId])
  @@index([updatedAt])
}

// Idempotency Keys for preventing duplicate submissions (e.g., booking, payment)
// Keys are stored with cached results and expire after 24 hours
model IdempotencyKey {
  id         String   @id @default(cuid())
  key        String   @unique // Client-provided unique key
  userId     String   // User who made the request
  endpoint   String   // Which endpoint (e.g., "createBooking")
  resultData Json?    // Cached result of the operation
  createdAt  DateTime @default(now())
  expiresAt  DateTime // Auto-expire after 24 hours

  @@index([expiresAt])
  @@index([userId, endpoint])
}
